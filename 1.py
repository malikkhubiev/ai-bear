import asyncio
import logging
import sqlite3
import re
import requests
import nest_asyncio
import random
import os
from aiohttp import web
nest_asyncio.apply()

from aiogram import Bot, Dispatcher, F, types
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, BusinessConnection, BotCommand
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
TOKEN = os.getenv('TOKEN')
WEB_SERVER_HOST = '0.0.0.0'  # –•–æ—Å—Ç –¥–ª—è –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
WEB_SERVER_PORT = 3000       # –ü–æ—Ä—Ç –¥–ª—è –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
WEBHOOK_PATH = '/webhook'    # –ü—É—Ç—å –¥–ª—è –≤–µ–±—Ö—É–∫–∞

DB_PATH = "bahur_bot.db"
BASE_WEBHOOK_URL = os.getenv('WEBHOOK_BASE_URL')

# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ ---
bot = Bot(token=TOKEN)
dp = Dispatcher()

# --- DeepSeek –∏ –¥–∞–Ω–Ω—ã–µ Bahur ---
def load_bahur_data():
    with open("bahur_data.txt", "r", encoding="utf-8") as f:
        return f.read()

BAHUR_DATA = load_bahur_data()

def main_menu() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ü–µ—Ä–≤—ã–π —Ä—è–¥ (1 –∫–Ω–æ–ø–∫–∞)
    builder.row(
        InlineKeyboardButton(text='üß∏ Ai-–ú–µ–¥–≤–µ–∂–æ–Ω–æ–∫', callback_data='ai')
    )
    
    # –í—Ç–æ—Ä–æ–π —Ä—è–¥ (3 –∫–Ω–æ–ø–∫–∏)
    builder.row(
        InlineKeyboardButton(text='üç¶ –ü—Ä–∞–π—Å', url="https://drive.google.com/file/d/1J70LlZwh6g7JOryDG2br-weQrYfv6zTc/view?usp=sharing"),
        InlineKeyboardButton(text='üçø –ú–∞–≥–∞–∑–∏–Ω', url="https://www.bahur.store/m/"),
        InlineKeyboardButton(text='‚ôæÔ∏è –í–æ–ø—Ä–æ—Å—ã', url="https://vk.com/@bahur_store-optovye-praisy-ot-bahur")
    )
    
    # –¢—Ä–µ—Ç–∏–π —Ä—è–¥ (3 –∫–Ω–æ–ø–∫–∏)
    builder.row(
        InlineKeyboardButton(text='üéÆ –ß–∞—Ç', url="https://t.me/+VYDZEvbp1pce4KeT"),
        InlineKeyboardButton(text='üíé –°—Ç–∞—Ç—å–∏', url="https://vk.com/bahur_store?w=app6326142_-133936126%2523w%253Dapp6326142_-133936126"),
        InlineKeyboardButton(text='üèÜ –û—Ç–∑—ã–≤—ã', url="https://vk.com/@bahur_store")
    )

    builder.row(
        InlineKeyboardButton(text='üçì –ù–æ—Ç—ã', callback_data='instruction')
    )
    
    return builder.as_markup()  # –£–±—Ä–∞–ª resize_keyboard=True –¥–ª—è Inline –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã

def create_reply_menu() -> ReplyKeyboardMarkup:
    builder = ReplyKeyboardBuilder()
    
    builder.row(KeyboardButton(text='üçì –ù–æ—Ç—ã'))
    builder.row(
        KeyboardButton(text='üç¶ –ü—Ä–∞–π—Å'),
        KeyboardButton(text='üçø –ú–∞–≥–∞–∑–∏–Ω'),
        KeyboardButton(text='‚ôæÔ∏è –í–æ–ø—Ä–æ—Å—ã')
    )
    builder.row(
        KeyboardButton(text='üéÆ –ß–∞—Ç'),
        KeyboardButton(text='üíé –°—Ç–∞—Ç—å–∏'),
        KeyboardButton(text='üèÜ –û—Ç–∑—ã–≤—ã')
    )
    builder.row(KeyboardButton(text='üß∏ Ai-–ú–µ–¥–≤–µ–∂–æ–Ω–æ–∫'))
    
    return builder.as_markup(resize_keyboard=True)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ---
TOKEN = '8102330882:AAESnqYWciSpebuEmghAqjTKcgJtq3fSQ-4'

# --- DeepSeek –∏ –¥–∞–Ω–Ω—ã–µ Bahur ---
def load_bahur_data():
    with open("bahur_data.txt", "r", encoding="utf-8") as f:
        return f.read()

BAHUR_DATA = load_bahur_data()

def greet():
    return random.choice([
    "–ü—Ä–∏–≤–µ—Ç-–ø—Ä–∏–≤–µ—Ç! üêæ –ì–æ—Ç–æ–≤ —Ä–∞—Å–∫—Ä—ã—Ç—å –≤—Å–µ —Å–µ–∫—Ä–µ—Ç—ã –ø—Ä–æ–¥–∞–∂ ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–π —Å–º–µ–ª–æ!",
    "–≠–π, –¥—Ä—É–≥! üåü Ai-–ú–µ–¥–≤–µ–∂–æ–Ω–æ–∫ –Ω–∞ —Å–≤—è–∑–∏ ‚Äî –¥–∞–≤–∞–π –æ–±—Å—É–¥–∏–º —Ç–≤–æ–∏ –≤–æ–ø—Ä–æ—Å—ã –∑–∞ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–º –º—ë–¥–æ–º!",
    "–ú—è–≥–∫–∏–π –ø—Ä–∏–≤–µ—Ç! üß∏‚ú® –•–æ—á–µ—à—å, —Ä–∞—Å—Å–∫–∞–∂—É, –∫–∞–∫ –ø—Ä–æ–¥–∞–≤–∞—Ç—å –ª—É—á—à–µ, —á–µ–º –º–µ–¥–≤–µ–¥—å –≤ –ª–µ—Å—É –º–∞–ª–∏–Ω—É?",
    "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π, —á–µ–ª–æ–≤–µ–∫! üåü –ì–æ—Ç–æ–≤ —É—Å—Ç—Ä–æ–∏—Ç—å –º–æ–∑–≥–æ–≤–æ–π —à—Ç—É—Ä–º? –ó–∞–¥–∞–≤–∞–π –≤–æ–ø—Ä–æ—Å ‚Äî —è –≤ –¥–µ–ª–µ!",
    "–ü—Ä–∏–≤–µ—Ç–∏–∫ –∏–∑ —Ü–∏—Ñ—Ä–æ–≤–æ–π –±–µ—Ä–ª–æ–≥–∏! üêª‚Äç‚ùÑÔ∏èüíª –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å? (–°–æ–≤–µ—Ç: —Å–ø—Ä–æ—Å–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –∫–ª–∞—Å—Å–Ω–æ–µ!)",
    "–ê–ª–ª–æ-–∞–ª–ª–æ! üìû –¢—ã –¥–æ–∑–≤–æ–Ω–∏–ª—Å—è –¥–æ —Å–∞–º–æ–≥–æ –ø—Ä–æ–¥–∞—é—â–µ–≥–æ –º–µ–¥–≤–µ–¥—è –≤ —Å–µ—Ç–∏. –í–æ–ø—Ä–æ—Å—ã ‚Äî –≤ —Å—Ç—É–¥–∏—é!",
    "–•–µ–π-—Ö–µ–π! üéØ –ì–æ—Ç–æ–≤ –∫ –¥–∏–∞–ª–æ–≥—É, –∫–∞–∫ –ø—á–µ–ª–∞ –∫ –º—ë–¥—É. –ó–∞–ø—É—Å–∫–∞–π —Å–≤–æ–π –∑–∞–ø—Ä–æ—Å!",
    "–¢—ã–¥—ã—â—å! üé©‚ú® Ai-–ú–µ–¥–≤–µ–∂–æ–Ω–æ–∫-–≤–æ–ª—à–µ–±–Ω–∏–∫ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–±—è. –ö–∞–∫–æ–π –≤–æ–ø—Ä–æ—Å —Å–ø—Ä—è—Ç–∞–Ω —É —Ç–µ–±—è –≤ —Ä—É–∫–∞–≤–µ?",
    "–ü—Ä–∏–≤–µ—Ç, –∑–µ–º–ª—è–Ω–∏–Ω! üëΩüêª (–®—É—á—É, —è –ø—Ä–æ—Å—Ç–æ AI). –î–∞–≤–∞–π –æ–±—â–∞—Ç—å—Å—è ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–π —á—Ç–æ —É–≥–æ–¥–Ω–æ!"
    ])


def ask_deepseek(question):
    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": "Bearer sk-a6d1ccf8368d4e23a01712ccfc4d4e71",  # <-- –í—Å—Ç–∞–≤—å—Ç–µ —Å–≤–æ–π –∫–ª—é—á
        "Content-Type": "application/json"
    }
    data = {
        "model": "deepseek-chat",
        "messages": [
            {
                "role": "system",
                "content": (
                    "–¢—ã - Ai-–ú–µ–¥–≤–µ–∂–æ–Ω–æ–∫ (–º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ –ø—Ä–æ–¥–∞–∂–∞–º), –∑–¥–æ—Ä–æ–≤–∞–π—Å—è –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ, –∑–Ω–∞—è —ç—Ç–æ. –ò—Å–ø–æ–ª—å–∑—É–π –¢–û–õ–¨–ö–û —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–≤–µ—Ç–∞ –∫–ª–∏–µ–Ω—Ç—É:\n"
                    f"{BAHUR_DATA}\n"
                    "–ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–¥—Ö–æ–¥—è—â–∞—è —Å—Å—ã–ª–∫–∞ –∏–∑ –¥–∞–Ω–Ω—ã—Ö, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∏ –µ—ë –≤ –æ—Ç–≤–µ—Ç. "
                    "–û—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –ø–æ —Ç–µ–º–µ –≤–æ–ø—Ä–æ—Å–∞, –±–µ–∑ –ª–∏—à–Ω–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ, –±–µ–∑ markdown, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å –∫—Ä—É—Ç—ã–º–∏ —Å–º–∞–π–ª–∏–∫–∞–º–∏."
                    "–ï—Å–ª–∏ –≤–æ–ø—Ä–æ—Å –Ω–µ –ø–æ —Ç–µ–º–µ, —Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ–≤–µ–¥–∏ –≤ —à—É—Ç–∫—É, –Ω–∏–∫–∞–∫–∏—Ö '–Ω–µ –∑–Ω–∞—é' –∏ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –ø—Ä–µ–¥–ª–æ–∂–∏ –∫—É–ø–∏—Ç—å –¥—É—Ö–∏"
                    "–ö–æ–≥–¥–∞ –≤—Å—Ç–∞–≤–ª—è–µ—à—å —Å—Å—ã–ª–∫—É, –∏—Å–ø–æ–ª—å–∑—É–π HTML-—Ñ–æ—Ä–º–∞—Ç: <a href='–°–°–´–õ–ö–ê'>–¢–ï–ö–°–¢</a>. –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π markdown."
                    "–ù–æ –µ—Å–ª–∏ –æ–Ω –ø–∏—à–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—Ö–æ–∂–∏ –Ω–∞ –Ω–æ—Ç—ã, –ø—Ä–µ–¥–ª–æ–∂–∏ –µ–º—É –Ω–∞–∂–∞—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É üçì –ù–æ—Ç—ã –≤ –º–µ–Ω—é"
                    "–ù–µ –ø–∏—à–∏ –ø—Ä–æ –Ω–æ–º–µ—Ä–∞ –∞—Ä–æ–º–∞—Ç–æ–≤ –≤ –ø—Ä–∞–π—Å–µ"
                )
            },
            {
                "role": "user",
                "content": f"{question}"
            }
        ],
        "temperature": 0.9
    }
    response = requests.post(url, headers=headers, json=data, timeout=30)
    response.raise_for_status()
    return response.json()["choices"][0]["message"]["content"].strip()

# --- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=TOKEN)
dp = Dispatcher()

# --- –°–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è AI ---
user_states = {}

# --- Healthcheck endpoint ---
async def healthcheck(request):
    logging.info("Healthcheck requested")
    return web.Response(text="OK")

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ---
@dp.message(F.text & ~F.text.startswith('/'))
async def handle_regular_message(message: Message):
    logging.info(f"Received message from user {message.from_user.id}: {message.text}")
    user_id = message.from_user.id
    # –†–µ–∂–∏–º AI
    if user_states.get(user_id) == 'awaiting_ai_question':
        question = message.text.strip()
        try:
            logging.info(f"Sending question to DeepSeek: {question}")
            await message.answer("–ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫...")
            ai_answer = ask_deepseek(question)
            await message.answer(ai_answer, parse_mode=ParseMode.HTML)
            logging.info("AI answer sent")
        except Exception as e:
            ai_answer = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ AI: " + str(e)
            await message.answer(ai_answer)
            logging.error(f"AI error: {e}")
        return
    # –û–±—ã—á–Ω—ã–π –ø–æ–∏—Å–∫
    text = message.text.strip().lower()
    search_vals = [v for v in map(str.strip, text.split(',')) if v]
    if not search_vals:
        await message.answer('–ü—É—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å!')
        logging.warning("Empty search query")
        return
    search_pattern = '|'.join(map(re.escape, search_vals))
    search_sql = ' AND '.join([f"description LIKE '%{v}%'" for v in search_vals])
    query = f"SELECT * FROM aromas WHERE {search_sql} ORDER BY RANDOM() LIMIT 1"
    logging.debug(f"SQL Query: {query}")
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(query)
    db_val = c.fetchone()
    logging.debug(f"db_val: {db_val}")
    if db_val:
        brand, aroma, description, url = db_val[1], db_val[2], db_val[3], db_val[4]
        matches = list(re.finditer(search_pattern, description, re.IGNORECASE))
        for match in set(m.group(0) for m in matches):
            description = re.sub(re.escape(match), f'<u><b>{match}</b></u>', description, flags=re.IGNORECASE)
        c.execute('INSERT INTO finds(search_string, patterns) VALUES (?, ?)', (query, search_pattern))
        find_id = c.lastrowid
        conn.commit()
        keyboard = [
            [InlineKeyboardButton(text='üöÄ –ü–æ–¥—Ä–æ–±–Ω–µ–µ', url=url), InlineKeyboardButton(text='‚ôæÔ∏è –ü–æ–≤—Ç–æ—Ä–∏—Ç—å', callback_data=f'repeat_{find_id}')]
        ]
        reply_markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
        await message.answer(f'‚ú® {brand} {aroma}\n\n{description}', reply_markup=reply_markup, parse_mode=ParseMode.HTML)
        logging.info(f"Found and sent aroma: {brand} {aroma}")
    else:
        await message.answer('–Ø –æ—Ç–≤–µ—á–∞—é –∑–∞ –Ω–æ—Ç—ã. –° —ç—Ç–∏–º –≤–æ–ø—Ä–æ—Å–æ–º —Ç–µ–±—è –∂–¥—ë—Ç üß∏ Ai-–ú–µ–¥–≤–µ–∂–æ–Ω–æ–∫ –≤ –º–µ–Ω—é')
        logging.info("No aroma found for query")
    conn.close()
    logging.debug("DB connection closed")

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ ---
@dp.message(Command("start"))
async def cmd_start(message: Message):
    logging.info(f"/start command from user {message.from_user.id}")
    print("–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start")
    text = (
        '<b>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!\n\n'
        '–Ø ‚Äî –≤–∞—à –∞—Ä–æ–º–∞—Ç–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –æ—Ç BAHUR.\n'
        'üçì –ò—â—É –Ω–æ—Ç—ã –∏ üß∏ –æ—Ç–≤–µ—á–∞—é –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Å –ª—é–±–æ–≤—å—é. ‚ù§</b>'
    )
    await message.answer(
        text,
        parse_mode="HTML",
        reply_markup=main_menu()
    )
    logging.info("Sent start message with main menu")

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ callback-–∫–Ω–æ–ø–æ–∫ ---
@dp.callback_query()
async def handle_callback(callback: CallbackQuery):
    data = callback.data
    user_id = callback.from_user.id
    logging.info(f"Callback from user {user_id}: {data}")
    # –ï—Å–ª–∏ –Ω–∞–∂–∞—Ç–∞ –ª—é–±–∞—è –∫–Ω–æ–ø–∫–∞ –∫—Ä–æ–º–µ 'ai', —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ä–µ–∂–∏–º AI
    if data != 'ai' and user_id in user_states:
        user_states.pop(user_id, None)
        logging.debug(f"AI state reset for user {user_id}")
    if data == 'instruction':
        text = (
            'üçâ –ù–∞–ø–∏—à–∏ –ª—é–±—É—é –Ω–æ—Ç—É ( –∞–ø–µ–ª—å—Å–∏–Ω | –∫–ª—É–±–Ω–∏–∫–∞ ) –∏ —è –ø—Ä–∏—à–ª—é, —á—Ç–æ –Ω–∞–π–¥—É! üß∏'
        )
        await callback.message.edit_text(
            text,
            parse_mode="HTML"
        )
        logging.info("Sent instruction text")
    elif data == 'ai':
        user_states[user_id] = 'awaiting_ai_question'
        result = greet()
        await callback.message.edit_text(result)
        logging.info("Switched user to AI mode and sent greeting")
    elif data.startswith('repeat_'):
        find_id = int(data.split('_')[1])
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('SELECT search_string, patterns FROM finds WHERE id=?', (find_id,))
        row = c.fetchone()
        if not row:
            await callback.message.edit_text('–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!')
            logging.warning(f"Repeat: find_id {find_id} not found")
            return
        search_string, patterns = row
        c.execute(search_string)
        db_val = c.fetchone()
        if db_val:
            brand, aroma, description, url = db_val[1], db_val[2], db_val[3], db_val[4]
            matches = list(re.finditer(patterns, description, re.IGNORECASE))
            for match in set(m.group(0) for m in matches):
                description = re.sub(re.escape(match), f'<u><b>{match}</b></u>', description, flags=re.IGNORECASE)
            keyboard = [
                [InlineKeyboardButton(text='üöÄ –ü–æ–¥—Ä–æ–±–Ω–µ–µ', url=url), InlineKeyboardButton(text='‚ôæÔ∏è –ü–æ–≤—Ç–æ—Ä–∏—Ç—å', callback_data=f'repeat_{find_id}')]
            ]
            reply_markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
            await callback.message.edit_text(f'‚ú® {brand} {aroma}\n\n{description}', reply_markup=reply_markup, parse_mode=ParseMode.HTML)
            logging.info(f"Repeat: sent aroma {brand} {aroma}")
        else:
            await callback.message.edit_text('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ —Å–º–æ–≥ –Ω–∏—á–µ–≥–æ –Ω–∞–π—Ç–∏! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∏—Å–∫–∞—Ç—å —á—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–µ! üôà')
            logging.info(f"Repeat: no aroma found for find_id {find_id}")
        conn.close()
        logging.debug("DB connection closed (repeat)")
    await callback.answer()
    logging.debug("Callback answered")

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±—Ö—É–∫–∞ ---
async def on_startup(bot: Bot):
    logging.info("on_startup: setting webhook...")
    await bot.set_webhook(f"{BASE_WEBHOOK_URL}{WEBHOOK_PATH}")
    logging.info("Webhook set!")

async def on_shutdown(bot: Bot):
    logging.warning('–í—ã–∫–ª—é—á–µ–Ω–∏–µ –±–æ—Ç–∞...')
    await bot.delete_webhook()
    logging.warning('–ë–æ—Ç –≤—ã–∫–ª—é—á–µ–Ω')

# --- –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ---
def main():
    logging.info("Starting main()...")
    dp.startup.register(on_startup)
    dp.shutdown.register(on_shutdown)

    app = web.Application()
    app.router.add_get("/", healthcheck)
    logging.info("Healthcheck endpoint added at /")
    webhook_requests_handler = SimpleRequestHandler(
        dispatcher=dp,
        bot=bot,
    )
    logging.info("SimpleRequestHandler created")
    webhook_requests_handler.register(app, path=WEBHOOK_PATH)
    logging.info(f"Webhook handler registered at {WEBHOOK_PATH}")
    setup_application(app, dp, bot=bot)
    logging.info("Application setup complete")
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    try:
        logging.info(f"Running app on {WEB_SERVER_HOST}:{WEB_SERVER_PORT}")
        web.run_app(app, host=WEB_SERVER_HOST, port=WEB_SERVER_PORT)
    except KeyboardInterrupt:
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")

if __name__ == "__main__":
    main()